#pragma once

namespace CPPWheels
{
    // 哈希表
    // 1. 概念：哈希表也叫散列表，是通过关键码key映射到表中的位置找到value的数据结构
    // 2. 散列函数：Func(key)从key映射到表中的地址从而访问数据
    // 3. 处理冲突的方法：
    //    3.1 开放寻址法：通过线性探测(顺位看是否冲突)或二次探测(左右跳跃式探测，如1^2,(-1)^2,2^2,(-2)^2)
    //    3.2 链寻址法：每个bucket都是一个链表，发生冲突直接接在链表后，适用于经常插入删除
    //    3.3 再哈希/散列法：构造多个哈希函数，一个冲突使用另一个，避免聚集，但是增加了计算时间
    //    3.4 伪随机探测再散列：也就是探测+散列来寻找不冲突的地址。如果是线性探测，就是对发生冲突的位置+1然后再散列；如果是伪随机则是+伪随机序列中的值
    //    再散列。

    // Questions
    // 1. std::map和std::unordered_map的对比
    // std::map是基于红黑树实现的，一种自平衡的二叉树,插入删除查找平均时间复杂度O(logn),会保持排序状态(默认升序)
    // std::unordered_map,内部通过哈希表/哈希映射实现，插入，删除，查找平均时间复杂度伪O(1)；如果哈希函数设计不当或有大量哈希冲突，性能最坏O(n)
    // 选择：有序或低内存且稳定效果选择std::map,内存占用无要求则用std::unordered_map。
    // 2. 什么是哈希冲突
    // 不同关键字通过相同哈希计算出相同的哈希地址，该种现象称为哈希冲突或哈希碰撞。
    // 3. 哈希表删除可能出现的问题
    // 3.1 对于链寻址法，删除指定bucket的链表节点不影响，可以重新存储数据
    // 3.2 对于开发寻址，直接删除则可能需要移动其它数据或者重新计算哈希值，所以一般都"懒惰删除"，标记为已删除。
    //   一般的处理方式是延后处理，当要插入新数据再插入
    //   另一方面，立即用新数据填充刚删除所留下的空位可能会导致哈希表空间利用率下降，甚至导致产生冲突的可能增大，影响性能。

    // 哈希表扩容卡顿优化
    // 1. 负载因子，已使用空间/总空间，根据程序的需求来进行选择合适的负载因子
    // 2. 增量扩容，将扩容操作分成多个小任务，每次移动一小部分元素
    // 3. 自定义哈希函数和分配器，选择适合你的数据的哈希函数
    // 4. 延迟扩容，推迟到不繁忙的时候扩容
    // 5. 渐进式扩容，随着插入逐渐扩容，而不是到达某个阈值直接扩容。

}